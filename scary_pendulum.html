<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>4-Point Pendulum</title>
  <style>
    html,body{height:100%;margin:0}
    canvas{display:block;background:#8B0000} 
  </style>
</head>
<body>
<canvas id="c"></canvas>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let w = canvas.width = innerWidth;
let h = canvas.height = innerHeight;

window.addEventListener('resize', ()=>{
  w = canvas.width = innerWidth;
  h = canvas.height = innerHeight;
});

// Pendulum parameters
const SEGMENTS = 4;              // number of connecting points (masses)
const SEG_LEN = 120;            // rest length of each segment in pixels
const ORIGIN = { x: w/2, y: 80 };
const GRAVITY = 1500;           // px/s^2
const TIMESTEP = 1/60;          // fixed timestep
const ITER = 6;                 // constraint solver iterations
const MASS_RADIUS = 10;         // draw radius for masses
const DAMPING = 0.999;         // global velocity damping


const particles = [];
function resetPendulum(){
  particles.length = 0;
  for(let i=0;i<SEGMENTS;i++){
    const x = ORIGIN.x;
    const y = ORIGIN.y + i*SEG_LEN;
    particles.push({ x, y, px: x, py: y, pinned: i===0, trail: [] });
  }
}
resetPendulum();

let dragging = false;
let dragIndex = -1;

function getMouse(e){
  if(e.touches) { const t = e.touches[0]; return { x: t.clientX, y: t.clientY }; }
  return { x: e.clientX, y: e.clientY };
}

canvas.addEventListener('pointerdown', (e)=>{
  const m = getMouse(e);
  let best = -1, bestDist = 1e9;
  for(let i=0;i<particles.length;i++){
    const p = particles[i];
    const dx = p.x - m.x, dy = p.y - m.y;
    const d2 = dx*dx + dy*dy;
    if(d2 < bestDist){ bestDist = d2; best = i; }
  }
  if(bestDist <= (MASS_RADIUS+10)*(MASS_RADIUS+10)){
    dragging = true;
    dragIndex = best;
    canvas.setPointerCapture(e.pointerId);
  }
});

canvas.addEventListener('pointermove', (e)=>{
  if(!dragging) return;
  const m = getMouse(e);
  const p = particles[dragIndex];
  p.x = m.x; p.y = m.y;
  p.px = m.x; p.py = m.y;
});

canvas.addEventListener('pointerup', (e)=>{ dragging=false; dragIndex=-1; try{ canvas.releasePointerCapture(e.pointerId) } catch(err){} });
canvas.addEventListener('pointercancel', ()=>{ dragging=false; dragIndex=-1; });

function integrate(dt){
  const gdt2 = GRAVITY * dt * dt;
  for(let i=0;i<particles.length;i++){
    const p = particles[i];
    if(p.pinned) continue;
    const nx = p.x + (p.x - p.px) * DAMPING;
    const ny = p.y + (p.y - p.py) * DAMPING + gdt2;
    p.px = p.x; p.py = p.y;
    p.x = nx; p.y = ny;
  }
}

function constrain(){
  const pivot = particles[0];
  pivot.x = ORIGIN.x; pivot.y = ORIGIN.y;
  pivot.px = ORIGIN.x; pivot.py = ORIGIN.y;

  for(let k=0;k<ITER;k++){
    for(let i=0;i<particles.length-1;i++){
      const a = particles[i];
      const b = particles[i+1];
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const dist = Math.hypot(dx,dy) || 0.0001;
      const diff = (dist - SEG_LEN)/dist;
      const invMassA = a.pinned ? 0 : 1;
      const invMassB = b.pinned ? 0 : 1;
      const invSum = invMassA + invMassB;
      if(invSum === 0) continue;
      const moveA = invMassA / invSum;
      const moveB = invMassB / invSum;
      const mx = dx * diff;
      const my = dy * diff;
      if(!a.pinned){ a.x += mx * moveA; a.y += my * moveA; }
      if(!b.pinned){ b.x -= mx * moveB; b.y -= my * moveB; }
    }
  }
}

const COLORS = ["#FF4500","#FFD700","#00CED1","#7FFF00"];

function draw(){
  ctx.fillStyle = "#8B0000";
  ctx.fillRect(0,0,w,h);
  ctx.save();
  ctx.lineWidth = 1; 
  ctx.strokeStyle = '#000';

  ctx.beginPath();
  for(let i=0;i<particles.length-1;i++){
    const a = particles[i];
    const b = particles[i+1];
    ctx.moveTo(a.x, a.y);
    ctx.lineTo(b.x, b.y);
  }
  ctx.stroke();

  // trails
  for(let i=0;i<particles.length;i++){
    const p = particles[i];
    p.trail.push({x:p.x,y:p.y});
    if(p.trail.length > 50) p.trail.shift();
    ctx.beginPath();
    for(let j=0;j<p.trail.length;j++){
      const t = p.trail[j];
      if(j===0) ctx.moveTo(t.x,t.y); else ctx.lineTo(t.x,t.y);
    }
    ctx.strokeStyle = COLORS[i % COLORS.length];
    ctx.stroke();
  }

  // masses
  for(let i=0;i<particles.length;i++){
    const p = particles[i];
    ctx.beginPath();
    ctx.arc(p.x, p.y, MASS_RADIUS, 0, Math.PI*2);
    ctx.fillStyle = COLORS[i % COLORS.length];
    ctx.fill();
  }
  ctx.restore();
}

let acc = 0;
let last = performance.now();
function loop(now){
  const dtMs = now - last;
  last = now;
  acc += dtMs/1000;
  if(acc > 0.25) acc = 0.25;

  while(acc >= TIMESTEP){
    integrate(TIMESTEP);
    constrain();
    acc -= TIMESTEP;
  }
  draw();
  requestAnimationFrame(loop);
}

function nudge(){
  for(let i=0;i<particles.length;i++){
    const p = particles[i];
    p.px = p.x - (i*3);
    p.py = p.y;
  }
}
nudge();
requestAnimationFrame(loop);

window.addEventListener('keydown', (e)=>{
  if(e.key === 'r' || e.key === 'R'){
    resetPendulum();
    nudge();
  }
});

window.addEventListener('resize', ()=>{ ORIGIN.x = innerWidth/2; });
</script>
</body>
</html>
