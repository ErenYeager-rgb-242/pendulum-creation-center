<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>4-Point Pendulum</title>
</head>
<body>
<style>
  body, html {
    margin: 0;
    padding: 0;
    overflow: hidden;
    width: 100%;
    height: 100%;
  }
  #c {
    display: block;
    margin: 0;
    padding: 0;
  }
</style>
<canvas id="c"></canvas>

<script>
// 4-segment pendulum using Verlet integration + distance constraints
// Click/touch and drag any bob to move it. Plain white background; rods and points in black.

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let w = canvas.width = innerWidth;
let h = canvas.height = innerHeight;

window.addEventListener('resize', ()=>{
  w = canvas.width = innerWidth;
  h = canvas.height = innerHeight;
});

// Pendulum parameters
const SEGMENTS = 4;              // number of connecting points (masses)
const SEG_LEN = 120;            // rest length of each segment in pixels
const ORIGIN = { x: w/2, y: 80 };
const GRAVITY = 1500;           // px/s^2
const TIMESTEP = 1/60;          // fixed timestep
const ITER = 6;                 // constraint solver iterations
const MASS_RADIUS = 10;         // draw radius for masses
const DAMPING = 0.999;         // global velocity damping

// Particle structure for Verlet: {x, y, px, py, pinned}
const particles = [];

function resetPendulum(){
  particles.length = 0;
  // first particle pinned to origin (pivot)
  for(let i=0;i<SEGMENTS;i++){
    const x = ORIGIN.x;
    const y = ORIGIN.y + i*SEG_LEN;
    particles.push({ x, y, px: x, py: y, pinned: i===0 });
  }
}

resetPendulum();

// Interaction
let dragging = false;
let dragIndex = -1;
let lastMouse = {x:0,y:0};

function getMouse(e){
  if(e.touches) {
    const t = e.touches[0];
    return { x: t.clientX, y: t.clientY };
  }
  return { x: e.clientX, y: e.clientY };
}

canvas.addEventListener('pointerdown', (e)=>{
  const m = getMouse(e);
  // find nearest particle within a threshold
  let best = -1, bestDist = 1e9;
  for(let i=0;i<particles.length;i++){
    const p = particles[i];
    const dx = p.x - m.x, dy = p.y - m.y;
    const d2 = dx*dx + dy*dy;
    if(d2 < bestDist){ bestDist = d2; best = i; }
  }
  if(bestDist <= (MASS_RADIUS+10)*(MASS_RADIUS+10)){
    dragging = true;
    dragIndex = best;
    lastMouse = m;
    // lock pointer movement to keep interactions crisp
    canvas.setPointerCapture(e.pointerId);
  }
});

canvas.addEventListener('pointermove', (e)=>{
  if(!dragging) return;
  const m = getMouse(e);
  const p = particles[dragIndex];
  // Move particle to pointer position (simple direct set)
  p.x = m.x; p.y = m.y;
  // To keep Verlet continuity, set previous position so velocity doesn't explode
  p.px = m.x; p.py = m.y;
  lastMouse = m;
});

canvas.addEventListener('pointerup', (e)=>{
  dragging = false;
  dragIndex = -1;
  try{ canvas.releasePointerCapture(e.pointerId) } catch(err){}
});

canvas.addEventListener('pointercancel', ()=>{ dragging=false; dragIndex=-1; });

// Touch fallback (should be covered by pointer events), but keep double-check
canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); }, {passive:false});

// Physics - Verlet integration
function integrate(dt){
  const gdt2 = GRAVITY * dt * dt;
  for(let i=0;i<particles.length;i++){
    const p = particles[i];
    if(p.pinned) continue;
    const nx = p.x + (p.x - p.px) * DAMPING;
    const ny = p.y + (p.y - p.py) * DAMPING + gdt2;
    p.px = p.x; p.py = p.y;
    p.x = nx; p.y = ny;
  }
}

// Solve distance constraints between successive particles; first one pinned to origin
function constrain(){
  // keep pivot at ORIGIN exactly
  const pivot = particles[0];
  pivot.x = ORIGIN.x; pivot.y = ORIGIN.y;
  pivot.px = ORIGIN.x; pivot.py = ORIGIN.y;

  for(let k=0;k<ITER;k++){
    for(let i=0;i<particles.length-1;i++){
      const a = particles[i];
      const b = particles[i+1];
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const dist = Math.hypot(dx,dy) || 0.0001;
      const diff = (dist - SEG_LEN)/dist;
      // how much to move each end (if pinned, move only the other)
      const invMassA = a.pinned ? 0 : 1;
      const invMassB = b.pinned ? 0 : 1;
      const invSum = invMassA + invMassB;
      // if both are pinned, skip
      if(invSum === 0) continue;
      const moveA = invMassA / invSum;
      const moveB = invMassB / invSum;
      const mx = dx * diff;
      const my = dy * diff;
      if(!a.pinned){ a.x += mx * moveA; a.y += my * moveA; }
      if(!b.pinned){ b.x -= mx * moveB; b.y -= my * moveB; }
    }
  }
}

// simple energy-preserving constraint to avoid drift: re-normalize from origin
function maintainLengths(){
  // optional: nothing here for now
}

// drawing
let dataPackets = [];
let signalPulses = [];
let voltageReadings = [];

function draw(){
  // Dark PCB background
  ctx.fillStyle = 'rgba(10, 40, 10, 0.1)';
  ctx.fillRect(0, 0, w, h);
  
  // PCB substrate pattern
  ctx.fillStyle = 'rgba(0, 50, 0, 0.3)';
  const patternSize = 15;
  for(let x = 0; x < w; x += patternSize){
    for(let y = 0; y < h; y += patternSize){
      if((Math.floor(x/patternSize) + Math.floor(y/patternSize)) % 2 === 0){
        ctx.fillRect(x, y, patternSize, patternSize);
      }
    }
  }
  
  // Update system stats dynamically
  if(!window.systemStats) {
    window.systemStats = {
      cpuUsage: 45.0,
      memoryUsed: 2.1,
      temperature: 42,
      uptime: 0,
      errors: 0
    };
  }

  // CPU usage based on pendulum motion
  let totalMotion = 0;
  for(let i = 0; i < particles.length; i++){
    const p = particles[i];
    const motion = Math.hypot(p.x - p.px, p.y - p.py);
    totalMotion += motion;
  }
  window.systemStats.cpuUsage = Math.min(95, 20 + totalMotion * 2);
  window.systemStats.uptime += 0.016;
  window.systemStats.memoryUsed = 1.8 + (dataPackets.length / 10) + Math.sin(Date.now() * 0.001) * 0.3;
  window.systemStats.temperature = 25 + (window.systemStats.cpuUsage / 100) * 35 + Math.random() * 2;
  
  if(Math.random() < 0.002) window.systemStats.errors++;
  
  ctx.save();
  
  // Generate data packets flowing through connections
  if(Math.random() < 0.1){
    for(let i=0;i<particles.length-1;i++){
      const a = particles[i];
      const b = particles[i+1];
      dataPackets.push({
        startX: a.x, startY: a.y,
        endX: b.x, endY: b.y,
        progress: 0,
        speed: 0.02 + Math.random() * 0.03,
        data: ['0x' + Math.floor(Math.random()*256).toString(16).toUpperCase().padStart(2, '0'),
               'TCP', 'UDP', 'HTTP', 'SPI', 'I2C'][Math.floor(Math.random() * 6)],
        color: ['#00FF00', '#00AAFF', '#FF6600', '#FFFF00'][Math.floor(Math.random() * 4)]
      });
    }
  }
  
  // Update and draw data packets
  dataPackets = dataPackets.filter(packet => {
    packet.progress += packet.speed;
    
    if(packet.progress <= 1){
      const x = packet.startX + (packet.endX - packet.startX) * packet.progress;
      const y = packet.startY + (packet.endY - packet.startY) * packet.progress;
      
      // Packet visualization
      ctx.fillStyle = packet.color;
      ctx.shadowColor = packet.color;
      ctx.shadowBlur = 5;
      
      ctx.beginPath();
      ctx.arc(x, y, 3, 0, Math.PI*2);
      ctx.fill();
      
      // Data label
      ctx.font = '8px "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.fillText(packet.data, x, y - 8);
      
      return true;
    }
    return false;
  });

  // Multi-layer PCB traces for pendulum arms
  for(let i=0;i<particles.length-1;i++){
    const a = particles[i];
    const b = particles[i+1];
    
    // Calculate perpendicular for trace separation
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const len = Math.hypot(dx, dy);
    const perpX = -dy / len;
    const perpY = dx / len;
    
    // Power traces (red - VCC)
    ctx.strokeStyle = '#FF4444';
    ctx.lineWidth = 4;
    ctx.shadowColor = '#FF4444';
    ctx.shadowBlur = 3;
    
    ctx.beginPath();
    ctx.moveTo(a.x + perpX * 8, a.y + perpY * 8);
    ctx.lineTo(b.x + perpX * 8, b.y + perpY * 8);
    ctx.stroke();
    
    // Ground traces (black/dark)
    ctx.strokeStyle = '#666666';
    ctx.lineWidth = 4;
    ctx.shadowColor = '#666666';
    ctx.shadowBlur = 2;
    
    ctx.beginPath();
    ctx.moveTo(a.x - perpX * 8, a.y - perpY * 8);
    ctx.lineTo(b.x - perpX * 8, b.y - perpY * 8);
    ctx.stroke();
    
    // Data/signal traces (green)
    ctx.strokeStyle = '#00FF44';
    ctx.lineWidth = 3;
    ctx.shadowColor = '#00FF44';
    ctx.shadowBlur = 4;
    
    ctx.beginPath();
    ctx.moveTo(a.x + perpX * 3, a.y + perpY * 3);
    ctx.lineTo(b.x + perpX * 3, b.y + perpY * 3);
    ctx.stroke();
    
    // Clock traces (yellow)
    ctx.strokeStyle = '#FFFF44';
    ctx.lineWidth = 2;
    ctx.shadowColor = '#FFFF44';
    ctx.shadowBlur = 3;
    
    ctx.beginPath();
    ctx.moveTo(a.x - perpX * 3, a.y - perpY * 3);
    ctx.lineTo(b.x - perpX * 3, b.y - perpY * 3);
    ctx.stroke();
    
    // Via connections (small copper holes)
    const numVias = 5;
    for(let j = 1; j < numVias; j++){
      const t = j / numVias;
      const viaX = a.x + (b.x - a.x) * t;
      const viaY = a.y + (b.y - a.y) * t;
      
      // Via hole
      ctx.fillStyle = '#000000';
      ctx.beginPath();
      ctx.arc(viaX, viaY, 2, 0, Math.PI*2);
      ctx.fill();
      
      // Via copper ring
      ctx.strokeStyle = '#DAA520';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(viaX, viaY, 3, 0, Math.PI*2);
      ctx.stroke();
    }
  }

  // Generate signal pulses
  if(Math.random() < 0.05){
    signalPulses.push({
      x: particles[0].x,
      y: particles[0].y,
      radius: 5,
      maxRadius: 50,
      color: '#00AAFF',
      life: 1
    });
  }
  
  // Draw signal pulses (like oscilloscope readings)
  signalPulses = signalPulses.filter(pulse => {
    pulse.radius += 2;
    pulse.life -= 0.02;
    
    if(pulse.life > 0 && pulse.radius < pulse.maxRadius){
      ctx.strokeStyle = `rgba(0, 170, 255, ${pulse.life})`;
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      
      ctx.beginPath();
      ctx.arc(pulse.x, pulse.y, pulse.radius, 0, Math.PI*2);
      ctx.stroke();
      ctx.setLineDash([]);
      
      return true;
    }
    return false;
  });

  // Computer Engineering components as pendulum masses
  for(let i=0;i<particles.length;i++){
    const p = particles[i];
    
    if(i === 0){
      // Main processor/controller
      const chipSize = MASS_RADIUS + 6;
      
      // Processor package
      ctx.fillStyle = '#2C2C2C';
      ctx.strokeStyle = '#DAA520';
      ctx.lineWidth = 2;
      ctx.fillRect(p.x - chipSize, p.y - chipSize, chipSize * 2, chipSize * 2);
      ctx.strokeRect(p.x - chipSize, p.y - chipSize, chipSize * 2, chipSize * 2);
      
      // Pin grid array
      for(let px = -2; px <= 2; px++){
        for(let py = -2; py <= 2; py++){
          ctx.fillStyle = '#DAA520';
          ctx.fillRect(p.x + px * 3 - 0.5, p.y + py * 3 - 0.5, 1, 1);
        }
      }
      
      // Processor label
      ctx.fillStyle = '#FFFFFF';
      ctx.font = '8px "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.fillText('ARM', p.x, p.y - 2);
      ctx.fillText('CORTEX', p.x, p.y + 6);
      
    } else {
      // Memory/peripheral chips
      const componentTypes = ['SRAM', 'FLASH', 'ADC', 'GPIO'];
      const colors = ['#FF4444', '#44FF44', '#4444FF', '#FFFF44'];
      const componentType = componentTypes[i % componentTypes.length];
      const componentColor = colors[i % colors.length];
      
      // Component package (SOIC/QFN style)
      ctx.fillStyle = '#1A1A1A';
      ctx.strokeStyle = componentColor;
      ctx.lineWidth = 2;
      ctx.shadowColor = componentColor;
      ctx.shadowBlur = 5;
      
      ctx.fillRect(p.x - MASS_RADIUS - 2, p.y - MASS_RADIUS - 2, 
                   (MASS_RADIUS + 2) * 2, (MASS_RADIUS + 2) * 2);
      ctx.strokeRect(p.x - MASS_RADIUS - 2, p.y - MASS_RADIUS - 2, 
                     (MASS_RADIUS + 2) * 2, (MASS_RADIUS + 2) * 2);
      
      // Component pins
      for(let pin = 0; pin < 8; pin++){
        const side = Math.floor(pin / 2);
        const pinPos = (pin % 2) * 2 - 1;
        let pinX, pinY;
        
        switch(side){
          case 0: pinX = p.x + pinPos * 5; pinY = p.y - MASS_RADIUS - 5; break;
          case 1: pinX = p.x + MASS_RADIUS + 5; pinY = p.y + pinPos * 5; break;
          case 2: pinX = p.x + pinPos * 5; pinY = p.y + MASS_RADIUS + 5; break;
          case 3: pinX = p.x - MASS_RADIUS - 5; pinY = p.y + pinPos * 5; break;
        }
        
        ctx.fillStyle = '#C0C0C0';
        ctx.fillRect(pinX - 1, pinY - 0.5, 2, 1);
      }
      
      // Component label
      ctx.fillStyle = componentColor;
      ctx.font = '7px "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.fillText(componentType, p.x, p.y + 2);
      
      // Status LED
      const isActive = Math.sin(Date.now() * 0.01 + i) > 0;
      if(isActive){
        ctx.fillStyle = '#00FF00';
        ctx.shadowColor = '#00FF00';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(p.x + MASS_RADIUS - 2, p.y - MASS_RADIUS + 2, 2, 0, Math.PI*2);
        ctx.fill();
      }
    }
  }

    // Responsive System Monitor Panel
  const scale = Math.min(w / 1200, h / 800);
  const panelW = 340 * scale;
  const panelH = 140 * scale;
  const panelX = w * 0.02;
  const panelY = h * 0.02;

  ctx.fillStyle = 'rgba(0,0,0,0.8)';
  ctx.fillRect(panelX, panelY, panelW, panelH);
  ctx.strokeStyle = window.systemStats.cpuUsage > 70 ? '#FF4444' : '#00FF00';
  ctx.lineWidth = 1 * scale;
  ctx.strokeRect(panelX, panelY, panelW, panelH);

  ctx.fillStyle = window.systemStats.cpuUsage > 80 ? '#FF4444' : '#00FF00';
  ctx.font = `${16 * scale}px "Courier New", monospace`;
  ctx.textAlign = 'left';

  let lineH = 20 * scale;
  let textX = panelX + 5 * scale;
  let y = panelY + lineH;

  ctx.fillText('╔══════ SYSTEM MONITOR ══════╗', textX, y); y += lineH;
  ctx.fillText(`║ CPU: ${window.systemStats.cpuUsage.toFixed(1)}%`, textX, y); y += lineH;
  ctx.fillText(`║ Memory: ${window.systemStats.memoryUsed.toFixed(1)}GB/4.0GB`, textX, y); y += lineH;
  ctx.fillText(`║ Temperature: ${window.systemStats.temperature.toFixed(1)}°C`, textX, y); y += lineH;
  ctx.fillText(`║ Packets: ${dataPackets.length} Errors: ${window.systemStats.errors}`, textX, y); y += lineH;
  ctx.fillText(`║ Uptime: ${Math.floor(window.systemStats.uptime)}s`, textX, y); y += lineH;
  ctx.fillText('╚═════════════════════════════╝', textX, y);

  ctx.restore();
}

// main loop with fixed timestep accumulator
let acc = 0;
let last = performance.now();
function loop(now){
  const dtMs = now - last;
  last = now;
  acc += dtMs/1000;
  // cap accumulator to avoid spiral of death
  if(acc > 0.25) acc = 0.25;

  while(acc >= TIMESTEP){
    integrate(TIMESTEP);
    constrain();
    acc -= TIMESTEP;
  }

  draw();
  requestAnimationFrame(loop);
}

// initialize previous positions slightly offset so pendulum starts moving
function nudge(){
  for(let i=0;i<particles.length;i++){
    const p = particles[i];
    p.px = p.x - (i*3); // small initial angular offset
    p.py = p.y;
  }
}

nudge();
requestAnimationFrame(loop);

// Allow resetting or re-centering with R key
window.addEventListener('keydown', (e)=>{
  if(e.key === 'r' || e.key === 'R'){
    resetPendulum();
    nudge();
  }
});

// Keep origin updated if user resizes: place pivot at top center
window.addEventListener('resize', ()=>{
  ORIGIN.x = innerWidth/2;
});

</script>
</body>
</html>
